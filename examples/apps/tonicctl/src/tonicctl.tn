defmodule TonicCtl do
  def run() do
    case find_command(System.argv()) do
      "none" -> ok(plan())
      command -> dispatch(command)
    end
  end

  def plan() do
    %{
      tool: :tonicctl,
      mode: :executable,
      commands: [:doctor, :gates, :bench_strict, :release_dry_run],
      usage: usage(),
      notes: notes()
    }
  end

  def find_command(argv) do
    case argv do
      [] -> "none"
      ["help" | _] -> "help"
      ["doctor" | _] -> "doctor"
      ["gates" | _] -> "gates"
      ["bench" | _] -> "bench"
      ["release" | _] -> "release"
      [_ | rest] -> find_command(rest)
      _ -> "none"
    end
  end

  def dispatch(command) do
    case command do
      "help" -> ok(plan())
      "doctor" -> execute_doctor(doctor_plan())
      "gates" -> execute_gates(gates_plan())
      "bench" -> execute_bench_strict(bench_strict_plan())
      "release" -> execute_release_dry_run(release_dry_run_plan())
      _ -> err("unknown command: #{command}")
    end
  end

  def usage() do
    [
      "tonic run examples/apps/tonicctl doctor",
      "tonic run examples/apps/tonicctl gates",
      "tonic run examples/apps/tonicctl bench",
      "tonic run examples/apps/tonicctl release"
    ]
  end

  def doctor_plan() do
    [
      %{check: :command, value: "cargo", required: true},
      %{check: :command, value: "rustc", required: true},
      %{check: :command, value: "python3", required: true},
      %{check: :command, value: "cc", required: true},
      %{check: :file, value: "scripts/native-gates.sh", required: true},
      %{check: :file, value: "benchmarks/native-compiler-suite.toml", required: true},
      %{check: :file, value: "benchmarks/native-compiled-suite.toml", required: true}
    ]
  end

  def gates_plan() do
    [
      "cargo fmt --all -- --check",
      "cargo clippy --all-targets --all-features -- -D warnings",
      "cargo test",
      "./scripts/differential-enforce.sh",
      "./scripts/llvm-catalog-parity-enforce.sh",
      "./scripts/native-gates.sh"
    ]
  end

  def bench_strict_plan() do
    [
      %{
        target: :interpreter,
        commands: [
          "TONIC_BENCH_ENFORCE=0 TONIC_BENCH_JSON_OUT=.tonic/native-gates/native-compiler-summary.json TONIC_BENCH_MARKDOWN_OUT=.tonic/native-gates/native-compiler-summary.md ./scripts/bench-native-contract-enforce.sh benchmarks/native-compiler-suite.toml",
          "./scripts/native-regression-policy.sh .tonic/native-gates/native-compiler-summary.json --mode strict"
        ]
      },
      %{
        target: :compiled,
        commands: [
          "TONIC_BENCH_ENFORCE=0 TONIC_BENCH_TARGET_NAME=compiled TONIC_BENCH_JSON_OUT=.tonic/native-gates/native-compiled-summary.json TONIC_BENCH_MARKDOWN_OUT=.tonic/native-gates/native-compiled-summary.md ./scripts/bench-native-contract-enforce.sh benchmarks/native-compiled-suite.toml",
          "./scripts/native-regression-policy.sh .tonic/native-gates/native-compiled-summary.json --mode strict"
        ]
      }
    ]
  end

  def release_dry_run_plan() do
    %{
      preflight: [
        "git status --short",
        "tonic run examples/apps/tonicctl doctor"
      ],
      required_gates: [
        "tonic run examples/apps/tonicctl gates",
        "tonic run examples/apps/tonicctl bench"
      ],
      artifacts: [
        ".tonic/release/native-compiler-summary.json",
        ".tonic/release/native-compiler-summary.md",
        ".tonic/release/native-compiled-summary.json",
        ".tonic/release/native-compiled-summary.md"
      ],
      policy: "tag cut is blocked unless both strict policy verdicts are pass"
    }
  end

  def notes() do
    [
      "This is a pure-tonic executable command dispatcher.",
      "Keep this example aligned with scripts/native-gates.sh and docs/release-checklist.md."
    ]
  end

  def execute_doctor(plan) do
    with _results <- for step <- plan do
      case step.check do
        :command -> check_command(step.value)?
        :file -> check_file(step.value)?
        _ -> err("unknown check type")?
      end
    end do
      ok(:ok)
    end
  end

  def check_command(cmd) do
    case System.which(cmd) do
      nil -> err("doctor failed: required command '#{cmd}' not found")
      path -> ok(:ok)
    end
  end

  def check_file(path) do
    case System.path_exists(path) do
      false -> err("doctor failed: required file '#{path}' not found")
      true -> ok(:ok)
      _ -> err("unexpected result from path_exists")
    end
  end

  def execute_gates(plan) do
    with _results <- for command <- plan do execute_command(command)? end do
      ok(:ok)
    end
  end

  def execute_bench_strict(plan) do
    with _results <- for target <- plan, command <- target.commands do execute_command(command)? end do
      ok(:ok)
    end
  end

  def execute_release_dry_run(plan) do
    with _preflight <- for command <- plan.preflight do execute_command(command)? end,
         _gates <- for command <- plan.required_gates do execute_command(command)? end,
         _artifacts <- for file <- plan.artifacts do check_file(file)? end do
      ok(:ok)
    end
  end

  def execute_command(command) do
    case System.run(command) do
      %{exit_code: 0} -> ok(:ok)
      %{exit_code: code, output: output} -> err("command failed with exit code #{code} and output:\n#{output}")
      _ -> err("unexpected result from System.run")
    end
  end
end
