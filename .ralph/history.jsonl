{"ts":"2026-02-20T21:17:25.995377910Z","type":{"kind":"loop_started","prompt":"# Implementation Plan (Micro-TDD) — Language Core v0\n\nConvert the design into a series of implementation steps that build each component in a test-driven, incremental way. Each step below ends in a working, demoable increment and integrates with prior steps.\n\n## Progress Checklist\n\n- [ ] Step 1: Bootstrap workspace + acceptance backpressure harness + BDD foundation\n- [ ] Step 2: Lexer for Elixir-inspired token set\n- [ ] Step 3: Parser for modules/functions and core expressions\n- [ ] Step 4: Parser extensions for pipe + pattern forms\n- [ ] Step 5: Resolver + module graph foundation\n- [ ] Step 6: Static type inference core + explicit `dynamic` escape hatch\n- [ ] Step 7: Result-first semantics + `?` propagation + exhaustiveness checks\n- [ ] Step 8: Lowering typed AST to executable core IR\n- [ ] Step 9: Interpreter runtime + `tonic run` end-to-end execution\n- [ ] Step 10: Core data model + protocols + Enum-style stdlib subset\n- [ ] Step 11: Project manifest/module loader + lazy stdlib loading\n- [ ] Step 12: On-disk compiled cache + invalidation rules\n- [ ] Step 13: `check/test/fmt/verify` + BDD dual-run modes + performance gate enforcement\n\n---\n\n## Step 1: Bootstrap workspace + acceptance backpressure harness + BDD foundation\n\n**Objective**\nCreate the Rust workspace, CLI skeleton, and acceptance verification scaffolding with a BDD source-of-truth model so every future slice is gate-driven.\n\n**Implementation guidance**\n- Create crates/modules for: `cli`, `frontend`, `resolver`, `typing`, `ir`, `runtime`, `verify`.\n- Add `tonic` command skeleton (`run/check/test/fmt/cache/verify`).\n- Add `acceptance/<slice-id>.yaml` schema + parser + status reporter.\n- Add `acceptance/features/<slice-id>.feature` support and scenario tag parsing (`@auto`, `@agent-manual`, `@human-manual`).\n\n**Micro TDD tasks**\n1. **Red:** CLI smoke test expects listed commands in `--help` output.\n2. **Green:** implement command skeleton with stable exit codes.\n3. **Red:** verification test expects failure when acceptance file missing.\n4. **Green:** implement acceptance file loading + explicit error.\n5. **Red:** feature parser test validates tags and scenario IDs.\n6. **Green:** implement minimal feature parsing and mode selection metadata.\n7. **Refactor:** extract shared CLI diagnostics and acceptance parsing utilities.\n\n**Test requirements**\n- Unit tests for command routing, acceptance parser, and BDD feature tag parsing.\n- Integration test for `tonic verify run step-01 --mode auto`.\n\n**Integration with previous work**\n- Establishes backpressure mechanism and BDD acceptance contract required by design.\n\n**Demo**\n- `tonic --help` shows all v0 commands.\n- `tonic verify run step-01 --mode auto` reads acceptance YAML + linked feature file and outputs pass/fail JSON.\n\n---\n\n## Step 2: Lexer for Elixir-inspired token set\n\n**Objective**\nImplement deterministic tokenization for v0 syntax subset.\n\n**Implementation guidance**\n- Support identifiers, atoms, numbers, strings, operators, delimiters, `defmodule/def/if/case/cond/fn` keywords, `|>`.\n- Preserve source spans for diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** token golden test for a minimal module file.\n2. **Green:** implement baseline scanner for identifiers/literals.\n3. **Red:** operator/keyword token test (`|>`, `->`, `:` atoms, etc.).\n4. **Green:** add operator and keyword tokenization.\n5. **Refactor:** unify span handling and error token reporting.\n\n**Test requirements**\n- Golden token snapshots.\n- Invalid token diagnostics test.\n\n**Integration with previous work**\n- Feeds parser entrypoint added in Step 1.\n\n**Demo**\n- `tonic check examples/lexer_smoke.tn --dump-tokens` prints expected token stream.\n\n---\n\n## Step 3: Parser for modules/functions and core expressions\n\n**Objective**\nParse modules, function declarations, and core expressions into AST.\n\n**Implementation guidance**\n- AST support for `defmodule`, `def`, function params, literals, calls, `if`.\n- Keep parser deterministic and span-rich.\n\n**Micro TDD tasks**\n1. **Red:** parse test for single-module two-function file.\n2. **Green:** implement module/function parser path.\n3. **Red:** expression parse test for call nesting and precedence.\n4. **Green:** implement expression parser with precedence table.\n5. **Refactor:** AST node constructors with stable IDs.\n\n**Test requirements**\n- AST snapshot tests.\n- Parse error recovery tests (single-file).\n\n**Integration with previous work**\n- Consumes lexer output from Step 2.\n\n**Demo**\n- `tonic check examples/parser_smoke.tn --dump-ast` outputs valid AST.\n\n---\n\n## Step 4: Parser extensions for pipe + pattern forms\n\n**Objective**\nAdd parsing for pipe chains and pattern forms needed by `case` and function heads.\n\n**Implementation guidance**\n- Parse `|>` chain nodes.\n- Parse tuple/list/map/wildcard/bind patterns.\n- Parse `case`/`cond` branches with pattern heads.\n\n**Micro TDD tasks**\n1. **Red:** parse test for multi-stage pipe chain.\n2. **Green:** implement pipe AST lowering shape.\n3. **Red:** parse test for tuple/list/map patterns in `case`.\n4. **Green:** implement pattern parser variants.\n5. **Refactor:** normalize branch representation for future type checking.\n\n**Test requirements**\n- Pattern syntax fixtures.\n- Parser diagnostics for malformed pattern branches.\n\n**Integration with previous work**\n- Extends Step 3 AST model without breaking existing fixtures.\n\n**Demo**\n- `tonic check examples/pipes_patterns.tn --dump-ast` succeeds.\n\n---\n\n## Step 5: Resolver + module graph foundation\n\n**Objective**\nResolve symbols and module references with clear diagnostics.\n\n**Implementation guidance**\n- Build scoped symbol tables.\n- Resolve local names, module-qualified names, and imports.\n- Create initial module graph representation.\n\n**Micro TDD tasks**\n1. **Red:** undefined symbol test should emit deterministic error code.\n2. **Green:** implement local scope symbol resolution.\n3. **Red:** import resolution test across two modules.\n4. **Green:** implement module reference resolution.\n5. **Refactor:** centralize resolver diagnostics and codes.\n\n**Test requirements**\n- Resolver unit tests (shadowing, ambiguity, missing imports).\n- Two-module integration fixture.\n\n**Integration with previous work**\n- Takes AST from Steps 3–4 and prepares typed analysis input.\n\n**Demo**\n- `tonic check examples/multi_module_basic/` reports either resolved graph or actionable resolver errors.\n\n---\n\n## Step 6: Static type inference core + explicit `dynamic` escape hatch\n\n**Objective**\nImplement mostly strict static inference with explicit `dynamic` boundaries.\n\n**Implementation guidance**\n- Infer primitive/composite/function types.\n- Reject implicit unsafe coercions.\n- Allow explicit `dynamic` at controlled boundaries.\n\n**Micro TDD tasks**\n1. **Red:** inference test for polymorphic-like helper and concrete call sites.\n2. **Green:** implement base type constraints + unification.\n3. **Red:** mismatch test expects type error with spans.\n4. **Green:** add mismatch diagnostics and coercion rejection.\n5. **Red/Green:** explicit `dynamic` annotation accepted only where allowed.\n\n**Test requirements**\n- Inference suite + type error snapshots.\n- Dynamic boundary policy tests.\n\n**Integration with previous work**\n- Uses resolved AST from Step 5.\n\n**Demo**\n- `tonic check examples/type_inference_smoke.tn` passes; `examples/type_error_smoke.tn` fails with structured diagnostics.\n\n---\n\n## Step 7: Result-first semantics + `?` propagation + exhaustiveness checks\n\n**Objective**\nEnforce `ok/err`-first flow and compile-time match exhaustiveness.\n\n**Implementation guidance**\n- Add `Result<T,E>` typing rules.\n- Implement `?` propagation typing and lowering hooks.\n- Add non-exhaustive pattern diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** `?` on non-Result expression must fail type checking.\n2. **Green:** implement `?` typing rule for `Result`.\n3. **Red:** non-exhaustive `case` fixture should fail.\n4. **Green:** implement exhaustiveness checker for v0 pattern subset.\n5. **Refactor:** harmonize error codes/messages for Result+match failures.\n\n**Test requirements**\n- Result propagation tests.\n- Exhaustiveness matrix tests.\n\n**Integration with previous work**\n- Extends type checker and resolver outputs.\n\n**Demo**\n- `tonic check examples/result_flow.tn` passes.\n- `tonic check examples/non_exhaustive_case.tn` fails with expected error code.\n\n---\n\n## Step 8: Lowering typed AST to executable core IR\n\n**Objective**\nTranslate typed AST into compact, executable typed IR with source maps.\n\n**Implementation guidance**\n- Define core IR nodes for expressions, branches, calls, pattern checks.\n- Preserve source mapping for runtime diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** lowering snapshot for simple typed function.\n2. **Green:** implement lowering for literals/calls/control flow.\n3. **Red:** lowering snapshot for `?` and `case` branches.\n4. **Green:** implement lowering for Result/match constructs.\n5. **Refactor:** canonicalize IR forms for interpreter simplicity.\n\n**Test requirements**\n- IR snapshot tests.\n- Source map integrity tests.\n\n**Integration with previous work**\n- Consumes typed module from Steps 6–7.\n\n**Demo**\n- `tonic check examples/ir_smoke.tn --dump-ir` outputs stable IR.\n\n---\n\n## Step 9: Interpreter runtime + `tonic run` end-to-end execution\n\n**Objective**\nExecute core IR deterministically for CLI scripts.\n\n**Implementation guidance**\n- Implement call frames, value model, control-flow execution.\n- Return `ok/err` semantics through CLI exit behavior.\n- Wire `tonic run` to full frontend->runtime path.\n\n**Micro TDD tasks**\n1. **Red:** E2E run test for arithmetic/script output.\n2. **Green:** implement minimal evaluator loop.\n3. **Red:** runtime Result propagation behavior test.\n4. **Green:** implement `err` propagation and CLI exit code mapping.\n5. **Refactor:** frame/value internals for lower allocation churn.\n\n**Test requirements**\n- Runtime unit tests for evaluator ops.\n- End-to-end `tonic run` fixtures.\n\n**Integration with previous work**\n- Executes IR from Step 8.\n\n**Demo**\n- `tonic run examples/hello.tn` prints expected output with stable exit status.\n\n---\n\n## Step 10: Core data model + protocols + Enum-style stdlib subset\n\n**Objective**\nDeliver practical v0 language ergonomics: maps/tuples/keywords, protocols, and core collection APIs.\n\n**Implementation guidance**\n- Implement runtime representations for tuple/map/list/keyword list.\n- Add protocol declaration/implementation/dispatch (v0 subset).\n- Implement initial Enum-style functions used by core examples.\n\n**Micro TDD tasks**\n1. **Red:** map/tuple/keyword behavior fixture tests.\n2. **Green:** implement data structure runtime support.\n3. **Red:** protocol dispatch test across two concrete types.\n4. **Green:** implement protocol lookup/dispatch tables.\n5. **Red/Green:** pipe + Enum fixture for chained transformations.\n\n**Test requirements**\n- Stdlib behavior tests.\n- Protocol dispatch conformance tests.\n\n**Integration with previous work**\n- Extends interpreter semantics from Step 9.\n\n**Demo**\n- `tonic run examples/collections_protocols.tn` demonstrates pipelines + protocol dispatch.\n\n---\n\n## Step 11: Project manifest/module loader + lazy stdlib loading\n\n**Objective**\nSupport project-level execution using `tonic.toml` and module graph loading with lazy optional modules.\n\n**Implementation guidance**\n- Parse/validate manifest.\n- Build module graph for project-local modules.\n- Eager-load core modules; lazy-load optional stdlib modules on first use.\n\n**Micro TDD tasks**\n1. **Red:** manifest parse/validation tests.\n2. **Green:** implement manifest model and loader.\n3. **Red:** multi-module project run fixture test.\n4. **Green:** implement module loader and graph resolution.\n5. **Red/Green:** lazy-load test ensures optional module not loaded unless referenced.\n\n**Test requirements**\n- Manifest unit tests.\n- Multi-module integration tests.\n- Lazy-loading behavior tests (module-load tracing).\n\n**Integration with previous work**\n- Wraps runtime pipeline into project-level UX.\n\n**Demo**\n- `tonic run examples/project_smoke` executes multi-module project and logs lazy-load behavior in debug mode.\n\n---\n\n## Step 12: On-disk compiled cache + invalidation rules\n\n**Objective**\nAdd persistent cache for lowered typed IR to accelerate warm starts.\n\n**Implementation guidance**\n- Implement cache key (entry hash + dep hash + runtime version + target + flags).\n- Serialize/deserialize IR.\n- Invalidate on key mismatch; recover from corruption gracefully.\n\n**Micro TDD tasks**\n1. **Red:** cache hit/miss unit tests with synthetic keys.\n2. **Green:** implement cache key and storage interface.\n3. **Red:** integration test verifies second run uses cache.\n4. **Green:** wire cache lookup/store into run pipeline.\n5. **Red/Green:** corruption test forces fallback compile path.\n\n**Test requirements**\n- Cache unit + integration tests.\n- Deterministic invalidation tests.\n\n**Integration with previous work**\n- Accelerates Step 11 execution path; no behavior changes when cache misses.\n\n**Demo**\n- Running same script twice shows first compile path then cache-hit path; warm run latency improves.\n\n---\n\n## Step 13: `check/test/fmt/verify` + BDD dual-run modes + performance gate enforcement\n\n**Objective**\nComplete v0 developer workflow and enforce acceptance/performance backpressure through dual-run BDD verification before completion.\n\n**Implementation guidance**\n- Finalize `tonic check`, `tonic test`, `tonic fmt`, `tonic verify`.\n- Add `tonic verify` modes:\n  - `--mode auto` (run `@auto` scenarios only)\n  - `--mode mixed` (run `@auto` + `@agent-manual`)\n  - `--mode manual` (run full manual-tagged checks)\n- Add benchmark harness and CI thresholds:\n  - cold start p50 <= 50 ms\n  - warm start p50 <= 10 ms\n  - idle RSS <= 30 MB\n- Enforce acceptance files + feature links + step evidence requirements in verify flow.\n\n**Micro TDD tasks**\n1. **Red:** command integration tests for check/test/fmt paths.\n2. **Green:** implement missing command behavior and output contracts.\n3. **Red:** BDD mode tests assert tag filtering (`@auto`, `@agent-manual`, `@human-manual`).\n4. **Green:** implement dual-run BDD mode execution in verify runner.\n5. **Red:** benchmark gate test should fail when threshold exceeded.\n6. **Green:** implement threshold enforcement and structured report output.\n7. **Red/Green:** verify command must fail if required manual evidence JSON is missing.\n\n**Test requirements**\n- CLI integration suite for all commands.\n- BDD mode integration tests for auto/mixed/manual.\n- Performance benchmark tests in CI profile.\n- Acceptance workflow tests for blocked vs accepted statuses.\n\n**Integration with previous work**\n- Brings all components together into a complete, shippable v0 language-core toolchain with unified executable/manual acceptance.\n\n**Demo**\n- `tonic verify run step-13 --mode auto` runs only automated BDD scenarios.\n- `tonic verify run step-13 --mode mixed` requires agent-manual evidence and fails without it.\n- Completion succeeds only when tests, benchmarks, and required evidence checks all pass.\n\n---\n\n## Connections\n- [[../design/detailed-design.md]]\n- [[../idea-honing.md]]\n- [[../research/research-plan.md]]\n- [[../research/06-runtime-semantics-gap.md]]\n- [[../research/07-startup-memory-techniques.md]]\n- [[../research/08-toolchain-portability-gap.md]]\n- [[../research/09-terminal-portability-gap.md]]\n- [[../research/10-practitioner-signals.md]]\n"}}
{"ts":"2026-02-20T21:17:54.549219175Z","type":{"kind":"loop_started","prompt":"# Implementation Plan (Micro-TDD) — Language Core v0\n\nConvert the design into a series of implementation steps that build each component in a test-driven, incremental way. Each step below ends in a working, demoable increment and integrates with prior steps.\n\n## Progress Checklist\n\n- [ ] Step 1: Bootstrap workspace + acceptance backpressure harness + BDD foundation\n- [ ] Step 2: Lexer for Elixir-inspired token set\n- [ ] Step 3: Parser for modules/functions and core expressions\n- [ ] Step 4: Parser extensions for pipe + pattern forms\n- [ ] Step 5: Resolver + module graph foundation\n- [ ] Step 6: Static type inference core + explicit `dynamic` escape hatch\n- [ ] Step 7: Result-first semantics + `?` propagation + exhaustiveness checks\n- [ ] Step 8: Lowering typed AST to executable core IR\n- [ ] Step 9: Interpreter runtime + `tonic run` end-to-end execution\n- [ ] Step 10: Core data model + protocols + Enum-style stdlib subset\n- [ ] Step 11: Project manifest/module loader + lazy stdlib loading\n- [ ] Step 12: On-disk compiled cache + invalidation rules\n- [ ] Step 13: `check/test/fmt/verify` + BDD dual-run modes + performance gate enforcement\n\n---\n\n## Step 1: Bootstrap workspace + acceptance backpressure harness + BDD foundation\n\n**Objective**\nCreate the Rust workspace, CLI skeleton, and acceptance verification scaffolding with a BDD source-of-truth model so every future slice is gate-driven.\n\n**Implementation guidance**\n- Create crates/modules for: `cli`, `frontend`, `resolver`, `typing`, `ir`, `runtime`, `verify`.\n- Add `tonic` command skeleton (`run/check/test/fmt/cache/verify`).\n- Add `acceptance/<slice-id>.yaml` schema + parser + status reporter.\n- Add `acceptance/features/<slice-id>.feature` support and scenario tag parsing (`@auto`, `@agent-manual`, `@human-manual`).\n\n**Micro TDD tasks**\n1. **Red:** CLI smoke test expects listed commands in `--help` output.\n2. **Green:** implement command skeleton with stable exit codes.\n3. **Red:** verification test expects failure when acceptance file missing.\n4. **Green:** implement acceptance file loading + explicit error.\n5. **Red:** feature parser test validates tags and scenario IDs.\n6. **Green:** implement minimal feature parsing and mode selection metadata.\n7. **Refactor:** extract shared CLI diagnostics and acceptance parsing utilities.\n\n**Test requirements**\n- Unit tests for command routing, acceptance parser, and BDD feature tag parsing.\n- Integration test for `tonic verify run step-01 --mode auto`.\n\n**Integration with previous work**\n- Establishes backpressure mechanism and BDD acceptance contract required by design.\n\n**Demo**\n- `tonic --help` shows all v0 commands.\n- `tonic verify run step-01 --mode auto` reads acceptance YAML + linked feature file and outputs pass/fail JSON.\n\n---\n\n## Step 2: Lexer for Elixir-inspired token set\n\n**Objective**\nImplement deterministic tokenization for v0 syntax subset.\n\n**Implementation guidance**\n- Support identifiers, atoms, numbers, strings, operators, delimiters, `defmodule/def/if/case/cond/fn` keywords, `|>`.\n- Preserve source spans for diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** token golden test for a minimal module file.\n2. **Green:** implement baseline scanner for identifiers/literals.\n3. **Red:** operator/keyword token test (`|>`, `->`, `:` atoms, etc.).\n4. **Green:** add operator and keyword tokenization.\n5. **Refactor:** unify span handling and error token reporting.\n\n**Test requirements**\n- Golden token snapshots.\n- Invalid token diagnostics test.\n\n**Integration with previous work**\n- Feeds parser entrypoint added in Step 1.\n\n**Demo**\n- `tonic check examples/lexer_smoke.tn --dump-tokens` prints expected token stream.\n\n---\n\n## Step 3: Parser for modules/functions and core expressions\n\n**Objective**\nParse modules, function declarations, and core expressions into AST.\n\n**Implementation guidance**\n- AST support for `defmodule`, `def`, function params, literals, calls, `if`.\n- Keep parser deterministic and span-rich.\n\n**Micro TDD tasks**\n1. **Red:** parse test for single-module two-function file.\n2. **Green:** implement module/function parser path.\n3. **Red:** expression parse test for call nesting and precedence.\n4. **Green:** implement expression parser with precedence table.\n5. **Refactor:** AST node constructors with stable IDs.\n\n**Test requirements**\n- AST snapshot tests.\n- Parse error recovery tests (single-file).\n\n**Integration with previous work**\n- Consumes lexer output from Step 2.\n\n**Demo**\n- `tonic check examples/parser_smoke.tn --dump-ast` outputs valid AST.\n\n---\n\n## Step 4: Parser extensions for pipe + pattern forms\n\n**Objective**\nAdd parsing for pipe chains and pattern forms needed by `case` and function heads.\n\n**Implementation guidance**\n- Parse `|>` chain nodes.\n- Parse tuple/list/map/wildcard/bind patterns.\n- Parse `case`/`cond` branches with pattern heads.\n\n**Micro TDD tasks**\n1. **Red:** parse test for multi-stage pipe chain.\n2. **Green:** implement pipe AST lowering shape.\n3. **Red:** parse test for tuple/list/map patterns in `case`.\n4. **Green:** implement pattern parser variants.\n5. **Refactor:** normalize branch representation for future type checking.\n\n**Test requirements**\n- Pattern syntax fixtures.\n- Parser diagnostics for malformed pattern branches.\n\n**Integration with previous work**\n- Extends Step 3 AST model without breaking existing fixtures.\n\n**Demo**\n- `tonic check examples/pipes_patterns.tn --dump-ast` succeeds.\n\n---\n\n## Step 5: Resolver + module graph foundation\n\n**Objective**\nResolve symbols and module references with clear diagnostics.\n\n**Implementation guidance**\n- Build scoped symbol tables.\n- Resolve local names, module-qualified names, and imports.\n- Create initial module graph representation.\n\n**Micro TDD tasks**\n1. **Red:** undefined symbol test should emit deterministic error code.\n2. **Green:** implement local scope symbol resolution.\n3. **Red:** import resolution test across two modules.\n4. **Green:** implement module reference resolution.\n5. **Refactor:** centralize resolver diagnostics and codes.\n\n**Test requirements**\n- Resolver unit tests (shadowing, ambiguity, missing imports).\n- Two-module integration fixture.\n\n**Integration with previous work**\n- Takes AST from Steps 3–4 and prepares typed analysis input.\n\n**Demo**\n- `tonic check examples/multi_module_basic/` reports either resolved graph or actionable resolver errors.\n\n---\n\n## Step 6: Static type inference core + explicit `dynamic` escape hatch\n\n**Objective**\nImplement mostly strict static inference with explicit `dynamic` boundaries.\n\n**Implementation guidance**\n- Infer primitive/composite/function types.\n- Reject implicit unsafe coercions.\n- Allow explicit `dynamic` at controlled boundaries.\n\n**Micro TDD tasks**\n1. **Red:** inference test for polymorphic-like helper and concrete call sites.\n2. **Green:** implement base type constraints + unification.\n3. **Red:** mismatch test expects type error with spans.\n4. **Green:** add mismatch diagnostics and coercion rejection.\n5. **Red/Green:** explicit `dynamic` annotation accepted only where allowed.\n\n**Test requirements**\n- Inference suite + type error snapshots.\n- Dynamic boundary policy tests.\n\n**Integration with previous work**\n- Uses resolved AST from Step 5.\n\n**Demo**\n- `tonic check examples/type_inference_smoke.tn` passes; `examples/type_error_smoke.tn` fails with structured diagnostics.\n\n---\n\n## Step 7: Result-first semantics + `?` propagation + exhaustiveness checks\n\n**Objective**\nEnforce `ok/err`-first flow and compile-time match exhaustiveness.\n\n**Implementation guidance**\n- Add `Result<T,E>` typing rules.\n- Implement `?` propagation typing and lowering hooks.\n- Add non-exhaustive pattern diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** `?` on non-Result expression must fail type checking.\n2. **Green:** implement `?` typing rule for `Result`.\n3. **Red:** non-exhaustive `case` fixture should fail.\n4. **Green:** implement exhaustiveness checker for v0 pattern subset.\n5. **Refactor:** harmonize error codes/messages for Result+match failures.\n\n**Test requirements**\n- Result propagation tests.\n- Exhaustiveness matrix tests.\n\n**Integration with previous work**\n- Extends type checker and resolver outputs.\n\n**Demo**\n- `tonic check examples/result_flow.tn` passes.\n- `tonic check examples/non_exhaustive_case.tn` fails with expected error code.\n\n---\n\n## Step 8: Lowering typed AST to executable core IR\n\n**Objective**\nTranslate typed AST into compact, executable typed IR with source maps.\n\n**Implementation guidance**\n- Define core IR nodes for expressions, branches, calls, pattern checks.\n- Preserve source mapping for runtime diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** lowering snapshot for simple typed function.\n2. **Green:** implement lowering for literals/calls/control flow.\n3. **Red:** lowering snapshot for `?` and `case` branches.\n4. **Green:** implement lowering for Result/match constructs.\n5. **Refactor:** canonicalize IR forms for interpreter simplicity.\n\n**Test requirements**\n- IR snapshot tests.\n- Source map integrity tests.\n\n**Integration with previous work**\n- Consumes typed module from Steps 6–7.\n\n**Demo**\n- `tonic check examples/ir_smoke.tn --dump-ir` outputs stable IR.\n\n---\n\n## Step 9: Interpreter runtime + `tonic run` end-to-end execution\n\n**Objective**\nExecute core IR deterministically for CLI scripts.\n\n**Implementation guidance**\n- Implement call frames, value model, control-flow execution.\n- Return `ok/err` semantics through CLI exit behavior.\n- Wire `tonic run` to full frontend->runtime path.\n\n**Micro TDD tasks**\n1. **Red:** E2E run test for arithmetic/script output.\n2. **Green:** implement minimal evaluator loop.\n3. **Red:** runtime Result propagation behavior test.\n4. **Green:** implement `err` propagation and CLI exit code mapping.\n5. **Refactor:** frame/value internals for lower allocation churn.\n\n**Test requirements**\n- Runtime unit tests for evaluator ops.\n- End-to-end `tonic run` fixtures.\n\n**Integration with previous work**\n- Executes IR from Step 8.\n\n**Demo**\n- `tonic run examples/hello.tn` prints expected output with stable exit status.\n\n---\n\n## Step 10: Core data model + protocols + Enum-style stdlib subset\n\n**Objective**\nDeliver practical v0 language ergonomics: maps/tuples/keywords, protocols, and core collection APIs.\n\n**Implementation guidance**\n- Implement runtime representations for tuple/map/list/keyword list.\n- Add protocol declaration/implementation/dispatch (v0 subset).\n- Implement initial Enum-style functions used by core examples.\n\n**Micro TDD tasks**\n1. **Red:** map/tuple/keyword behavior fixture tests.\n2. **Green:** implement data structure runtime support.\n3. **Red:** protocol dispatch test across two concrete types.\n4. **Green:** implement protocol lookup/dispatch tables.\n5. **Red/Green:** pipe + Enum fixture for chained transformations.\n\n**Test requirements**\n- Stdlib behavior tests.\n- Protocol dispatch conformance tests.\n\n**Integration with previous work**\n- Extends interpreter semantics from Step 9.\n\n**Demo**\n- `tonic run examples/collections_protocols.tn` demonstrates pipelines + protocol dispatch.\n\n---\n\n## Step 11: Project manifest/module loader + lazy stdlib loading\n\n**Objective**\nSupport project-level execution using `tonic.toml` and module graph loading with lazy optional modules.\n\n**Implementation guidance**\n- Parse/validate manifest.\n- Build module graph for project-local modules.\n- Eager-load core modules; lazy-load optional stdlib modules on first use.\n\n**Micro TDD tasks**\n1. **Red:** manifest parse/validation tests.\n2. **Green:** implement manifest model and loader.\n3. **Red:** multi-module project run fixture test.\n4. **Green:** implement module loader and graph resolution.\n5. **Red/Green:** lazy-load test ensures optional module not loaded unless referenced.\n\n**Test requirements**\n- Manifest unit tests.\n- Multi-module integration tests.\n- Lazy-loading behavior tests (module-load tracing).\n\n**Integration with previous work**\n- Wraps runtime pipeline into project-level UX.\n\n**Demo**\n- `tonic run examples/project_smoke` executes multi-module project and logs lazy-load behavior in debug mode.\n\n---\n\n## Step 12: On-disk compiled cache + invalidation rules\n\n**Objective**\nAdd persistent cache for lowered typed IR to accelerate warm starts.\n\n**Implementation guidance**\n- Implement cache key (entry hash + dep hash + runtime version + target + flags).\n- Serialize/deserialize IR.\n- Invalidate on key mismatch; recover from corruption gracefully.\n\n**Micro TDD tasks**\n1. **Red:** cache hit/miss unit tests with synthetic keys.\n2. **Green:** implement cache key and storage interface.\n3. **Red:** integration test verifies second run uses cache.\n4. **Green:** wire cache lookup/store into run pipeline.\n5. **Red/Green:** corruption test forces fallback compile path.\n\n**Test requirements**\n- Cache unit + integration tests.\n- Deterministic invalidation tests.\n\n**Integration with previous work**\n- Accelerates Step 11 execution path; no behavior changes when cache misses.\n\n**Demo**\n- Running same script twice shows first compile path then cache-hit path; warm run latency improves.\n\n---\n\n## Step 13: `check/test/fmt/verify` + BDD dual-run modes + performance gate enforcement\n\n**Objective**\nComplete v0 developer workflow and enforce acceptance/performance backpressure through dual-run BDD verification before completion.\n\n**Implementation guidance**\n- Finalize `tonic check`, `tonic test`, `tonic fmt`, `tonic verify`.\n- Add `tonic verify` modes:\n  - `--mode auto` (run `@auto` scenarios only)\n  - `--mode mixed` (run `@auto` + `@agent-manual`)\n  - `--mode manual` (run full manual-tagged checks)\n- Add benchmark harness and CI thresholds:\n  - cold start p50 <= 50 ms\n  - warm start p50 <= 10 ms\n  - idle RSS <= 30 MB\n- Enforce acceptance files + feature links + step evidence requirements in verify flow.\n\n**Micro TDD tasks**\n1. **Red:** command integration tests for check/test/fmt paths.\n2. **Green:** implement missing command behavior and output contracts.\n3. **Red:** BDD mode tests assert tag filtering (`@auto`, `@agent-manual`, `@human-manual`).\n4. **Green:** implement dual-run BDD mode execution in verify runner.\n5. **Red:** benchmark gate test should fail when threshold exceeded.\n6. **Green:** implement threshold enforcement and structured report output.\n7. **Red/Green:** verify command must fail if required manual evidence JSON is missing.\n\n**Test requirements**\n- CLI integration suite for all commands.\n- BDD mode integration tests for auto/mixed/manual.\n- Performance benchmark tests in CI profile.\n- Acceptance workflow tests for blocked vs accepted statuses.\n\n**Integration with previous work**\n- Brings all components together into a complete, shippable v0 language-core toolchain with unified executable/manual acceptance.\n\n**Demo**\n- `tonic verify run step-13 --mode auto` runs only automated BDD scenarios.\n- `tonic verify run step-13 --mode mixed` requires agent-manual evidence and fails without it.\n- Completion succeeds only when tests, benchmarks, and required evidence checks all pass.\n\n---\n\n## Connections\n- [[../design/detailed-design.md]]\n- [[../idea-honing.md]]\n- [[../research/research-plan.md]]\n- [[../research/06-runtime-semantics-gap.md]]\n- [[../research/07-startup-memory-techniques.md]]\n- [[../research/08-toolchain-portability-gap.md]]\n- [[../research/09-terminal-portability-gap.md]]\n- [[../research/10-practitioner-signals.md]]\n"}}
{"ts":"2026-02-20T23:21:12.919630409Z","type":{"kind":"loop_started","prompt":"# Implementation Plan (Micro-TDD) — Language Core v0\n\nConvert the design into a series of implementation steps that build each component in a test-driven, incremental way. Each step below ends in a working, demoable increment and integrates with prior steps.\n\n## Progress Checklist\n\n- [ ] Step 1: Bootstrap workspace + acceptance backpressure harness + BDD foundation\n- [ ] Step 2: Lexer for Elixir-inspired token set\n- [ ] Step 3: Parser for modules/functions and core expressions\n- [ ] Step 4: Parser extensions for pipe + pattern forms\n- [ ] Step 5: Resolver + module graph foundation\n- [ ] Step 6: Static type inference core + explicit `dynamic` escape hatch\n- [ ] Step 7: Result-first semantics + `?` propagation + exhaustiveness checks\n- [ ] Step 8: Lowering typed AST to executable core IR\n- [ ] Step 9: Interpreter runtime + `tonic run` end-to-end execution\n- [ ] Step 10: Core data model + protocols + Enum-style stdlib subset\n- [ ] Step 11: Project manifest/module loader + lazy stdlib loading\n- [ ] Step 12: On-disk compiled cache + invalidation rules\n- [ ] Step 13: `check/test/fmt/verify` + BDD dual-run modes + performance gate enforcement\n\n---\n\n## Step 1: Bootstrap workspace + acceptance backpressure harness + BDD foundation\n\n**Objective**\nCreate the Rust workspace, CLI skeleton, and acceptance verification scaffolding with a BDD source-of-truth model so every future slice is gate-driven.\n\n**Implementation guidance**\n- Create crates/modules for: `cli`, `frontend`, `resolver`, `typing`, `ir`, `runtime`, `verify`.\n- Add `tonic` command skeleton (`run/check/test/fmt/cache/verify`).\n- Add `acceptance/<slice-id>.yaml` schema + parser + status reporter.\n- Add `acceptance/features/<slice-id>.feature` support and scenario tag parsing (`@auto`, `@agent-manual`, `@human-manual`).\n\n**Micro TDD tasks**\n1. **Red:** CLI smoke test expects listed commands in `--help` output.\n2. **Green:** implement command skeleton with stable exit codes.\n3. **Red:** verification test expects failure when acceptance file missing.\n4. **Green:** implement acceptance file loading + explicit error.\n5. **Red:** feature parser test validates tags and scenario IDs.\n6. **Green:** implement minimal feature parsing and mode selection metadata.\n7. **Refactor:** extract shared CLI diagnostics and acceptance parsing utilities.\n\n**Test requirements**\n- Unit tests for command routing, acceptance parser, and BDD feature tag parsing.\n- Integration test for `tonic verify run step-01 --mode auto`.\n\n**Integration with previous work**\n- Establishes backpressure mechanism and BDD acceptance contract required by design.\n\n**Demo**\n- `tonic --help` shows all v0 commands.\n- `tonic verify run step-01 --mode auto` reads acceptance YAML + linked feature file and outputs pass/fail JSON.\n\n---\n\n## Step 2: Lexer for Elixir-inspired token set\n\n**Objective**\nImplement deterministic tokenization for v0 syntax subset.\n\n**Implementation guidance**\n- Support identifiers, atoms, numbers, strings, operators, delimiters, `defmodule/def/if/case/cond/fn` keywords, `|>`.\n- Preserve source spans for diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** token golden test for a minimal module file.\n2. **Green:** implement baseline scanner for identifiers/literals.\n3. **Red:** operator/keyword token test (`|>`, `->`, `:` atoms, etc.).\n4. **Green:** add operator and keyword tokenization.\n5. **Refactor:** unify span handling and error token reporting.\n\n**Test requirements**\n- Golden token snapshots.\n- Invalid token diagnostics test.\n\n**Integration with previous work**\n- Feeds parser entrypoint added in Step 1.\n\n**Demo**\n- `tonic check examples/lexer_smoke.tn --dump-tokens` prints expected token stream.\n\n---\n\n## Step 3: Parser for modules/functions and core expressions\n\n**Objective**\nParse modules, function declarations, and core expressions into AST.\n\n**Implementation guidance**\n- AST support for `defmodule`, `def`, function params, literals, calls, `if`.\n- Keep parser deterministic and span-rich.\n\n**Micro TDD tasks**\n1. **Red:** parse test for single-module two-function file.\n2. **Green:** implement module/function parser path.\n3. **Red:** expression parse test for call nesting and precedence.\n4. **Green:** implement expression parser with precedence table.\n5. **Refactor:** AST node constructors with stable IDs.\n\n**Test requirements**\n- AST snapshot tests.\n- Parse error recovery tests (single-file).\n\n**Integration with previous work**\n- Consumes lexer output from Step 2.\n\n**Demo**\n- `tonic check examples/parser_smoke.tn --dump-ast` outputs valid AST.\n\n---\n\n## Step 4: Parser extensions for pipe + pattern forms\n\n**Objective**\nAdd parsing for pipe chains and pattern forms needed by `case` and function heads.\n\n**Implementation guidance**\n- Parse `|>` chain nodes.\n- Parse tuple/list/map/wildcard/bind patterns.\n- Parse `case`/`cond` branches with pattern heads.\n\n**Micro TDD tasks**\n1. **Red:** parse test for multi-stage pipe chain.\n2. **Green:** implement pipe AST lowering shape.\n3. **Red:** parse test for tuple/list/map patterns in `case`.\n4. **Green:** implement pattern parser variants.\n5. **Refactor:** normalize branch representation for future type checking.\n\n**Test requirements**\n- Pattern syntax fixtures.\n- Parser diagnostics for malformed pattern branches.\n\n**Integration with previous work**\n- Extends Step 3 AST model without breaking existing fixtures.\n\n**Demo**\n- `tonic check examples/pipes_patterns.tn --dump-ast` succeeds.\n\n---\n\n## Step 5: Resolver + module graph foundation\n\n**Objective**\nResolve symbols and module references with clear diagnostics.\n\n**Implementation guidance**\n- Build scoped symbol tables.\n- Resolve local names, module-qualified names, and imports.\n- Create initial module graph representation.\n\n**Micro TDD tasks**\n1. **Red:** undefined symbol test should emit deterministic error code.\n2. **Green:** implement local scope symbol resolution.\n3. **Red:** import resolution test across two modules.\n4. **Green:** implement module reference resolution.\n5. **Refactor:** centralize resolver diagnostics and codes.\n\n**Test requirements**\n- Resolver unit tests (shadowing, ambiguity, missing imports).\n- Two-module integration fixture.\n\n**Integration with previous work**\n- Takes AST from Steps 3–4 and prepares typed analysis input.\n\n**Demo**\n- `tonic check examples/multi_module_basic/` reports either resolved graph or actionable resolver errors.\n\n---\n\n## Step 6: Static type inference core + explicit `dynamic` escape hatch\n\n**Objective**\nImplement mostly strict static inference with explicit `dynamic` boundaries.\n\n**Implementation guidance**\n- Infer primitive/composite/function types.\n- Reject implicit unsafe coercions.\n- Allow explicit `dynamic` at controlled boundaries.\n\n**Micro TDD tasks**\n1. **Red:** inference test for polymorphic-like helper and concrete call sites.\n2. **Green:** implement base type constraints + unification.\n3. **Red:** mismatch test expects type error with spans.\n4. **Green:** add mismatch diagnostics and coercion rejection.\n5. **Red/Green:** explicit `dynamic` annotation accepted only where allowed.\n\n**Test requirements**\n- Inference suite + type error snapshots.\n- Dynamic boundary policy tests.\n\n**Integration with previous work**\n- Uses resolved AST from Step 5.\n\n**Demo**\n- `tonic check examples/type_inference_smoke.tn` passes; `examples/type_error_smoke.tn` fails with structured diagnostics.\n\n---\n\n## Step 7: Result-first semantics + `?` propagation + exhaustiveness checks\n\n**Objective**\nEnforce `ok/err`-first flow and compile-time match exhaustiveness.\n\n**Implementation guidance**\n- Add `Result<T,E>` typing rules.\n- Implement `?` propagation typing and lowering hooks.\n- Add non-exhaustive pattern diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** `?` on non-Result expression must fail type checking.\n2. **Green:** implement `?` typing rule for `Result`.\n3. **Red:** non-exhaustive `case` fixture should fail.\n4. **Green:** implement exhaustiveness checker for v0 pattern subset.\n5. **Refactor:** harmonize error codes/messages for Result+match failures.\n\n**Test requirements**\n- Result propagation tests.\n- Exhaustiveness matrix tests.\n\n**Integration with previous work**\n- Extends type checker and resolver outputs.\n\n**Demo**\n- `tonic check examples/result_flow.tn` passes.\n- `tonic check examples/non_exhaustive_case.tn` fails with expected error code.\n\n---\n\n## Step 8: Lowering typed AST to executable core IR\n\n**Objective**\nTranslate typed AST into compact, executable typed IR with source maps.\n\n**Implementation guidance**\n- Define core IR nodes for expressions, branches, calls, pattern checks.\n- Preserve source mapping for runtime diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** lowering snapshot for simple typed function.\n2. **Green:** implement lowering for literals/calls/control flow.\n3. **Red:** lowering snapshot for `?` and `case` branches.\n4. **Green:** implement lowering for Result/match constructs.\n5. **Refactor:** canonicalize IR forms for interpreter simplicity.\n\n**Test requirements**\n- IR snapshot tests.\n- Source map integrity tests.\n\n**Integration with previous work**\n- Consumes typed module from Steps 6–7.\n\n**Demo**\n- `tonic check examples/ir_smoke.tn --dump-ir` outputs stable IR.\n\n---\n\n## Step 9: Interpreter runtime + `tonic run` end-to-end execution\n\n**Objective**\nExecute core IR deterministically for CLI scripts.\n\n**Implementation guidance**\n- Implement call frames, value model, control-flow execution.\n- Return `ok/err` semantics through CLI exit behavior.\n- Wire `tonic run` to full frontend->runtime path.\n\n**Micro TDD tasks**\n1. **Red:** E2E run test for arithmetic/script output.\n2. **Green:** implement minimal evaluator loop.\n3. **Red:** runtime Result propagation behavior test.\n4. **Green:** implement `err` propagation and CLI exit code mapping.\n5. **Refactor:** frame/value internals for lower allocation churn.\n\n**Test requirements**\n- Runtime unit tests for evaluator ops.\n- End-to-end `tonic run` fixtures.\n\n**Integration with previous work**\n- Executes IR from Step 8.\n\n**Demo**\n- `tonic run examples/hello.tn` prints expected output with stable exit status.\n\n---\n\n## Step 10: Core data model + protocols + Enum-style stdlib subset\n\n**Objective**\nDeliver practical v0 language ergonomics: maps/tuples/keywords, protocols, and core collection APIs.\n\n**Implementation guidance**\n- Implement runtime representations for tuple/map/list/keyword list.\n- Add protocol declaration/implementation/dispatch (v0 subset).\n- Implement initial Enum-style functions used by core examples.\n\n**Micro TDD tasks**\n1. **Red:** map/tuple/keyword behavior fixture tests.\n2. **Green:** implement data structure runtime support.\n3. **Red:** protocol dispatch test across two concrete types.\n4. **Green:** implement protocol lookup/dispatch tables.\n5. **Red/Green:** pipe + Enum fixture for chained transformations.\n\n**Test requirements**\n- Stdlib behavior tests.\n- Protocol dispatch conformance tests.\n\n**Integration with previous work**\n- Extends interpreter semantics from Step 9.\n\n**Demo**\n- `tonic run examples/collections_protocols.tn` demonstrates pipelines + protocol dispatch.\n\n---\n\n## Step 11: Project manifest/module loader + lazy stdlib loading\n\n**Objective**\nSupport project-level execution using `tonic.toml` and module graph loading with lazy optional modules.\n\n**Implementation guidance**\n- Parse/validate manifest.\n- Build module graph for project-local modules.\n- Eager-load core modules; lazy-load optional stdlib modules on first use.\n\n**Micro TDD tasks**\n1. **Red:** manifest parse/validation tests.\n2. **Green:** implement manifest model and loader.\n3. **Red:** multi-module project run fixture test.\n4. **Green:** implement module loader and graph resolution.\n5. **Red/Green:** lazy-load test ensures optional module not loaded unless referenced.\n\n**Test requirements**\n- Manifest unit tests.\n- Multi-module integration tests.\n- Lazy-loading behavior tests (module-load tracing).\n\n**Integration with previous work**\n- Wraps runtime pipeline into project-level UX.\n\n**Demo**\n- `tonic run examples/project_smoke` executes multi-module project and logs lazy-load behavior in debug mode.\n\n---\n\n## Step 12: On-disk compiled cache + invalidation rules\n\n**Objective**\nAdd persistent cache for lowered typed IR to accelerate warm starts.\n\n**Implementation guidance**\n- Implement cache key (entry hash + dep hash + runtime version + target + flags).\n- Serialize/deserialize IR.\n- Invalidate on key mismatch; recover from corruption gracefully.\n\n**Micro TDD tasks**\n1. **Red:** cache hit/miss unit tests with synthetic keys.\n2. **Green:** implement cache key and storage interface.\n3. **Red:** integration test verifies second run uses cache.\n4. **Green:** wire cache lookup/store into run pipeline.\n5. **Red/Green:** corruption test forces fallback compile path.\n\n**Test requirements**\n- Cache unit + integration tests.\n- Deterministic invalidation tests.\n\n**Integration with previous work**\n- Accelerates Step 11 execution path; no behavior changes when cache misses.\n\n**Demo**\n- Running same script twice shows first compile path then cache-hit path; warm run latency improves.\n\n---\n\n## Step 13: `check/test/fmt/verify` + BDD dual-run modes + performance gate enforcement\n\n**Objective**\nComplete v0 developer workflow and enforce acceptance/performance backpressure through dual-run BDD verification before completion.\n\n**Implementation guidance**\n- Finalize `tonic check`, `tonic test`, `tonic fmt`, `tonic verify`.\n- Add `tonic verify` modes:\n  - `--mode auto` (run `@auto` scenarios only)\n  - `--mode mixed` (run `@auto` + `@agent-manual`)\n  - `--mode manual` (run full manual-tagged checks)\n- Add benchmark harness and CI thresholds:\n  - cold start p50 <= 50 ms\n  - warm start p50 <= 10 ms\n  - idle RSS <= 30 MB\n- Enforce acceptance files + feature links + step evidence requirements in verify flow.\n\n**Micro TDD tasks**\n1. **Red:** command integration tests for check/test/fmt paths.\n2. **Green:** implement missing command behavior and output contracts.\n3. **Red:** BDD mode tests assert tag filtering (`@auto`, `@agent-manual`, `@human-manual`).\n4. **Green:** implement dual-run BDD mode execution in verify runner.\n5. **Red:** benchmark gate test should fail when threshold exceeded.\n6. **Green:** implement threshold enforcement and structured report output.\n7. **Red/Green:** verify command must fail if required manual evidence JSON is missing.\n\n**Test requirements**\n- CLI integration suite for all commands.\n- BDD mode integration tests for auto/mixed/manual.\n- Performance benchmark tests in CI profile.\n- Acceptance workflow tests for blocked vs accepted statuses.\n\n**Integration with previous work**\n- Brings all components together into a complete, shippable v0 language-core toolchain with unified executable/manual acceptance.\n\n**Demo**\n- `tonic verify run step-13 --mode auto` runs only automated BDD scenarios.\n- `tonic verify run step-13 --mode mixed` requires agent-manual evidence and fails without it.\n- Completion succeeds only when tests, benchmarks, and required evidence checks all pass.\n\n---\n\n## Connections\n- [[../design/detailed-design.md]]\n- [[../idea-honing.md]]\n- [[../research/research-plan.md]]\n- [[../research/06-runtime-semantics-gap.md]]\n- [[../research/07-startup-memory-techniques.md]]\n- [[../research/08-toolchain-portability-gap.md]]\n- [[../research/09-terminal-portability-gap.md]]\n- [[../research/10-practitioner-signals.md]]\n"}}
{"ts":"2026-02-21T03:23:27.532466325Z","type":{"kind":"loop_completed","reason":"max_runtime"}}
{"ts":"2026-02-21T03:24:52.365952388Z","type":{"kind":"loop_started","prompt":"# Implementation Plan (Micro-TDD) — Language Core v0\n\nConvert the design into a series of implementation steps that build each component in a test-driven, incremental way. Each step below ends in a working, demoable increment and integrates with prior steps.\n\n## Progress Checklist\n\n- [ ] Step 1: Bootstrap workspace + acceptance backpressure harness + BDD foundation\n- [ ] Step 2: Lexer for Elixir-inspired token set\n- [ ] Step 3: Parser for modules/functions and core expressions\n- [ ] Step 4: Parser extensions for pipe + pattern forms\n- [ ] Step 5: Resolver + module graph foundation\n- [ ] Step 6: Static type inference core + explicit `dynamic` escape hatch\n- [ ] Step 7: Result-first semantics + `?` propagation + exhaustiveness checks\n- [ ] Step 8: Lowering typed AST to executable core IR\n- [ ] Step 9: Interpreter runtime + `tonic run` end-to-end execution\n- [ ] Step 10: Core data model + protocols + Enum-style stdlib subset\n- [ ] Step 11: Project manifest/module loader + lazy stdlib loading\n- [ ] Step 12: On-disk compiled cache + invalidation rules\n- [ ] Step 13: `check/test/fmt/verify` + BDD dual-run modes + performance gate enforcement\n\n---\n\n## Step 1: Bootstrap workspace + acceptance backpressure harness + BDD foundation\n\n**Objective**\nCreate the Rust workspace, CLI skeleton, and acceptance verification scaffolding with a BDD source-of-truth model so every future slice is gate-driven.\n\n**Implementation guidance**\n- Create crates/modules for: `cli`, `frontend`, `resolver`, `typing`, `ir`, `runtime`, `verify`.\n- Add `tonic` command skeleton (`run/check/test/fmt/cache/verify`).\n- Add `acceptance/<slice-id>.yaml` schema + parser + status reporter.\n- Add `acceptance/features/<slice-id>.feature` support and scenario tag parsing (`@auto`, `@agent-manual`, `@human-manual`).\n\n**Micro TDD tasks**\n1. **Red:** CLI smoke test expects listed commands in `--help` output.\n2. **Green:** implement command skeleton with stable exit codes.\n3. **Red:** verification test expects failure when acceptance file missing.\n4. **Green:** implement acceptance file loading + explicit error.\n5. **Red:** feature parser test validates tags and scenario IDs.\n6. **Green:** implement minimal feature parsing and mode selection metadata.\n7. **Refactor:** extract shared CLI diagnostics and acceptance parsing utilities.\n\n**Test requirements**\n- Unit tests for command routing, acceptance parser, and BDD feature tag parsing.\n- Integration test for `tonic verify run step-01 --mode auto`.\n\n**Integration with previous work**\n- Establishes backpressure mechanism and BDD acceptance contract required by design.\n\n**Demo**\n- `tonic --help` shows all v0 commands.\n- `tonic verify run step-01 --mode auto` reads acceptance YAML + linked feature file and outputs pass/fail JSON.\n\n---\n\n## Step 2: Lexer for Elixir-inspired token set\n\n**Objective**\nImplement deterministic tokenization for v0 syntax subset.\n\n**Implementation guidance**\n- Support identifiers, atoms, numbers, strings, operators, delimiters, `defmodule/def/if/case/cond/fn` keywords, `|>`.\n- Preserve source spans for diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** token golden test for a minimal module file.\n2. **Green:** implement baseline scanner for identifiers/literals.\n3. **Red:** operator/keyword token test (`|>`, `->`, `:` atoms, etc.).\n4. **Green:** add operator and keyword tokenization.\n5. **Refactor:** unify span handling and error token reporting.\n\n**Test requirements**\n- Golden token snapshots.\n- Invalid token diagnostics test.\n\n**Integration with previous work**\n- Feeds parser entrypoint added in Step 1.\n\n**Demo**\n- `tonic check examples/lexer_smoke.tn --dump-tokens` prints expected token stream.\n\n---\n\n## Step 3: Parser for modules/functions and core expressions\n\n**Objective**\nParse modules, function declarations, and core expressions into AST.\n\n**Implementation guidance**\n- AST support for `defmodule`, `def`, function params, literals, calls, `if`.\n- Keep parser deterministic and span-rich.\n\n**Micro TDD tasks**\n1. **Red:** parse test for single-module two-function file.\n2. **Green:** implement module/function parser path.\n3. **Red:** expression parse test for call nesting and precedence.\n4. **Green:** implement expression parser with precedence table.\n5. **Refactor:** AST node constructors with stable IDs.\n\n**Test requirements**\n- AST snapshot tests.\n- Parse error recovery tests (single-file).\n\n**Integration with previous work**\n- Consumes lexer output from Step 2.\n\n**Demo**\n- `tonic check examples/parser_smoke.tn --dump-ast` outputs valid AST.\n\n---\n\n## Step 4: Parser extensions for pipe + pattern forms\n\n**Objective**\nAdd parsing for pipe chains and pattern forms needed by `case` and function heads.\n\n**Implementation guidance**\n- Parse `|>` chain nodes.\n- Parse tuple/list/map/wildcard/bind patterns.\n- Parse `case`/`cond` branches with pattern heads.\n\n**Micro TDD tasks**\n1. **Red:** parse test for multi-stage pipe chain.\n2. **Green:** implement pipe AST lowering shape.\n3. **Red:** parse test for tuple/list/map patterns in `case`.\n4. **Green:** implement pattern parser variants.\n5. **Refactor:** normalize branch representation for future type checking.\n\n**Test requirements**\n- Pattern syntax fixtures.\n- Parser diagnostics for malformed pattern branches.\n\n**Integration with previous work**\n- Extends Step 3 AST model without breaking existing fixtures.\n\n**Demo**\n- `tonic check examples/pipes_patterns.tn --dump-ast` succeeds.\n\n---\n\n## Step 5: Resolver + module graph foundation\n\n**Objective**\nResolve symbols and module references with clear diagnostics.\n\n**Implementation guidance**\n- Build scoped symbol tables.\n- Resolve local names, module-qualified names, and imports.\n- Create initial module graph representation.\n\n**Micro TDD tasks**\n1. **Red:** undefined symbol test should emit deterministic error code.\n2. **Green:** implement local scope symbol resolution.\n3. **Red:** import resolution test across two modules.\n4. **Green:** implement module reference resolution.\n5. **Refactor:** centralize resolver diagnostics and codes.\n\n**Test requirements**\n- Resolver unit tests (shadowing, ambiguity, missing imports).\n- Two-module integration fixture.\n\n**Integration with previous work**\n- Takes AST from Steps 3–4 and prepares typed analysis input.\n\n**Demo**\n- `tonic check examples/multi_module_basic/` reports either resolved graph or actionable resolver errors.\n\n---\n\n## Step 6: Static type inference core + explicit `dynamic` escape hatch\n\n**Objective**\nImplement mostly strict static inference with explicit `dynamic` boundaries.\n\n**Implementation guidance**\n- Infer primitive/composite/function types.\n- Reject implicit unsafe coercions.\n- Allow explicit `dynamic` at controlled boundaries.\n\n**Micro TDD tasks**\n1. **Red:** inference test for polymorphic-like helper and concrete call sites.\n2. **Green:** implement base type constraints + unification.\n3. **Red:** mismatch test expects type error with spans.\n4. **Green:** add mismatch diagnostics and coercion rejection.\n5. **Red/Green:** explicit `dynamic` annotation accepted only where allowed.\n\n**Test requirements**\n- Inference suite + type error snapshots.\n- Dynamic boundary policy tests.\n\n**Integration with previous work**\n- Uses resolved AST from Step 5.\n\n**Demo**\n- `tonic check examples/type_inference_smoke.tn` passes; `examples/type_error_smoke.tn` fails with structured diagnostics.\n\n---\n\n## Step 7: Result-first semantics + `?` propagation + exhaustiveness checks\n\n**Objective**\nEnforce `ok/err`-first flow and compile-time match exhaustiveness.\n\n**Implementation guidance**\n- Add `Result<T,E>` typing rules.\n- Implement `?` propagation typing and lowering hooks.\n- Add non-exhaustive pattern diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** `?` on non-Result expression must fail type checking.\n2. **Green:** implement `?` typing rule for `Result`.\n3. **Red:** non-exhaustive `case` fixture should fail.\n4. **Green:** implement exhaustiveness checker for v0 pattern subset.\n5. **Refactor:** harmonize error codes/messages for Result+match failures.\n\n**Test requirements**\n- Result propagation tests.\n- Exhaustiveness matrix tests.\n\n**Integration with previous work**\n- Extends type checker and resolver outputs.\n\n**Demo**\n- `tonic check examples/result_flow.tn` passes.\n- `tonic check examples/non_exhaustive_case.tn` fails with expected error code.\n\n---\n\n## Step 8: Lowering typed AST to executable core IR\n\n**Objective**\nTranslate typed AST into compact, executable typed IR with source maps.\n\n**Implementation guidance**\n- Define core IR nodes for expressions, branches, calls, pattern checks.\n- Preserve source mapping for runtime diagnostics.\n\n**Micro TDD tasks**\n1. **Red:** lowering snapshot for simple typed function.\n2. **Green:** implement lowering for literals/calls/control flow.\n3. **Red:** lowering snapshot for `?` and `case` branches.\n4. **Green:** implement lowering for Result/match constructs.\n5. **Refactor:** canonicalize IR forms for interpreter simplicity.\n\n**Test requirements**\n- IR snapshot tests.\n- Source map integrity tests.\n\n**Integration with previous work**\n- Consumes typed module from Steps 6–7.\n\n**Demo**\n- `tonic check examples/ir_smoke.tn --dump-ir` outputs stable IR.\n\n---\n\n## Step 9: Interpreter runtime + `tonic run` end-to-end execution\n\n**Objective**\nExecute core IR deterministically for CLI scripts.\n\n**Implementation guidance**\n- Implement call frames, value model, control-flow execution.\n- Return `ok/err` semantics through CLI exit behavior.\n- Wire `tonic run` to full frontend->runtime path.\n\n**Micro TDD tasks**\n1. **Red:** E2E run test for arithmetic/script output.\n2. **Green:** implement minimal evaluator loop.\n3. **Red:** runtime Result propagation behavior test.\n4. **Green:** implement `err` propagation and CLI exit code mapping.\n5. **Refactor:** frame/value internals for lower allocation churn.\n\n**Test requirements**\n- Runtime unit tests for evaluator ops.\n- End-to-end `tonic run` fixtures.\n\n**Integration with previous work**\n- Executes IR from Step 8.\n\n**Demo**\n- `tonic run examples/hello.tn` prints expected output with stable exit status.\n\n---\n\n## Step 10: Core data model + protocols + Enum-style stdlib subset\n\n**Objective**\nDeliver practical v0 language ergonomics: maps/tuples/keywords, protocols, and core collection APIs.\n\n**Implementation guidance**\n- Implement runtime representations for tuple/map/list/keyword list.\n- Add protocol declaration/implementation/dispatch (v0 subset).\n- Implement initial Enum-style functions used by core examples.\n\n**Micro TDD tasks**\n1. **Red:** map/tuple/keyword behavior fixture tests.\n2. **Green:** implement data structure runtime support.\n3. **Red:** protocol dispatch test across two concrete types.\n4. **Green:** implement protocol lookup/dispatch tables.\n5. **Red/Green:** pipe + Enum fixture for chained transformations.\n\n**Test requirements**\n- Stdlib behavior tests.\n- Protocol dispatch conformance tests.\n\n**Integration with previous work**\n- Extends interpreter semantics from Step 9.\n\n**Demo**\n- `tonic run examples/collections_protocols.tn` demonstrates pipelines + protocol dispatch.\n\n---\n\n## Step 11: Project manifest/module loader + lazy stdlib loading\n\n**Objective**\nSupport project-level execution using `tonic.toml` and module graph loading with lazy optional modules.\n\n**Implementation guidance**\n- Parse/validate manifest.\n- Build module graph for project-local modules.\n- Eager-load core modules; lazy-load optional stdlib modules on first use.\n\n**Micro TDD tasks**\n1. **Red:** manifest parse/validation tests.\n2. **Green:** implement manifest model and loader.\n3. **Red:** multi-module project run fixture test.\n4. **Green:** implement module loader and graph resolution.\n5. **Red/Green:** lazy-load test ensures optional module not loaded unless referenced.\n\n**Test requirements**\n- Manifest unit tests.\n- Multi-module integration tests.\n- Lazy-loading behavior tests (module-load tracing).\n\n**Integration with previous work**\n- Wraps runtime pipeline into project-level UX.\n\n**Demo**\n- `tonic run examples/project_smoke` executes multi-module project and logs lazy-load behavior in debug mode.\n\n---\n\n## Step 12: On-disk compiled cache + invalidation rules\n\n**Objective**\nAdd persistent cache for lowered typed IR to accelerate warm starts.\n\n**Implementation guidance**\n- Implement cache key (entry hash + dep hash + runtime version + target + flags).\n- Serialize/deserialize IR.\n- Invalidate on key mismatch; recover from corruption gracefully.\n\n**Micro TDD tasks**\n1. **Red:** cache hit/miss unit tests with synthetic keys.\n2. **Green:** implement cache key and storage interface.\n3. **Red:** integration test verifies second run uses cache.\n4. **Green:** wire cache lookup/store into run pipeline.\n5. **Red/Green:** corruption test forces fallback compile path.\n\n**Test requirements**\n- Cache unit + integration tests.\n- Deterministic invalidation tests.\n\n**Integration with previous work**\n- Accelerates Step 11 execution path; no behavior changes when cache misses.\n\n**Demo**\n- Running same script twice shows first compile path then cache-hit path; warm run latency improves.\n\n---\n\n## Step 13: `check/test/fmt/verify` + BDD dual-run modes + performance gate enforcement\n\n**Objective**\nComplete v0 developer workflow and enforce acceptance/performance backpressure through dual-run BDD verification before completion.\n\n**Implementation guidance**\n- Finalize `tonic check`, `tonic test`, `tonic fmt`, `tonic verify`.\n- Add `tonic verify` modes:\n  - `--mode auto` (run `@auto` scenarios only)\n  - `--mode mixed` (run `@auto` + `@agent-manual`)\n  - `--mode manual` (run full manual-tagged checks)\n- Add benchmark harness and CI thresholds:\n  - cold start p50 <= 50 ms\n  - warm start p50 <= 10 ms\n  - idle RSS <= 30 MB\n- Enforce acceptance files + feature links + step evidence requirements in verify flow.\n\n**Micro TDD tasks**\n1. **Red:** command integration tests for check/test/fmt paths.\n2. **Green:** implement missing command behavior and output contracts.\n3. **Red:** BDD mode tests assert tag filtering (`@auto`, `@agent-manual`, `@human-manual`).\n4. **Green:** implement dual-run BDD mode execution in verify runner.\n5. **Red:** benchmark gate test should fail when threshold exceeded.\n6. **Green:** implement threshold enforcement and structured report output.\n7. **Red/Green:** verify command must fail if required manual evidence JSON is missing.\n\n**Test requirements**\n- CLI integration suite for all commands.\n- BDD mode integration tests for auto/mixed/manual.\n- Performance benchmark tests in CI profile.\n- Acceptance workflow tests for blocked vs accepted statuses.\n\n**Integration with previous work**\n- Brings all components together into a complete, shippable v0 language-core toolchain with unified executable/manual acceptance.\n\n**Demo**\n- `tonic verify run step-13 --mode auto` runs only automated BDD scenarios.\n- `tonic verify run step-13 --mode mixed` requires agent-manual evidence and fails without it.\n- Completion succeeds only when tests, benchmarks, and required evidence checks all pass.\n\n---\n\n## Connections\n- [[../design/detailed-design.md]]\n- [[../idea-honing.md]]\n- [[../research/research-plan.md]]\n- [[../research/06-runtime-semantics-gap.md]]\n- [[../research/07-startup-memory-techniques.md]]\n- [[../research/08-toolchain-portability-gap.md]]\n- [[../research/09-terminal-portability-gap.md]]\n- [[../research/10-practitioner-signals.md]]\n"}}
{"ts":"2026-02-21T04:11:14.854425944Z","type":{"kind":"loop_completed","reason":"completion_promise"}}
